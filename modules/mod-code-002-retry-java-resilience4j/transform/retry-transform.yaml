# ═══════════════════════════════════════════════════════════════════════════════
# Transform Descriptor: retry-transform.yaml
# Module: mod-code-002-retry-java-resilience4j
# ═══════════════════════════════════════════════════════════════════════════════
# Type: ANNOTATION TRANSFORMATION
# Target: Adapter classes that call external services (generated by mod-017)
# Purpose: Add @Retry annotations for transient failure recovery
# ═══════════════════════════════════════════════════════════════════════════════
#
# IMPORTANT: @Retry should be applied AFTER @CircuitBreaker (if both present).
# Execution order: @CircuitBreaker → @Retry → actual method
# This means retries happen INSIDE the circuit breaker window.
#
# Variables available from context:
#   {{serviceName}}     - e.g., "partiesApi"
#   {{entityName}}      - e.g., "Customer"
#   {{basePackage}}     - e.g., "com.bank.customer"
# ═══════════════════════════════════════════════════════════════════════════════

transformation:
  id: retry-annotation-transform
  type: annotation
  phase: 3
  description: "Add @Retry annotations for transient failure recovery"
  
  # Execution order within Phase 3
  # mod-001 (circuit-breaker) should run first, then mod-002 (retry)
  depends_on:
    - mod-code-001-circuit-breaker-java-resilience4j
  
  # ─────────────────────────────────────────────────────────────────────────────
  # TARGET SELECTION
  # ─────────────────────────────────────────────────────────────────────────────
  targets:
    - pattern: "**/adapter/out/**/*Adapter.java"
      description: "Output adapters that call external systems"
      generated_by:
        - mod-code-017-persistence-systemapi
      exclude:
        - "**/adapter/out/persistence/**"  # JPA adapters use DB transactions, not retry
        
  # ─────────────────────────────────────────────────────────────────────────────
  # TRANSFORMATIONS TO APPLY
  # ─────────────────────────────────────────────────────────────────────────────
  steps:
    
    # Step 1: Add imports
    - action: add_imports
      imports:
        - "io.github.resilience4j.retry.annotation.Retry"
      position: after_package
      deduplicate: true
      
    # Step 2: Add @Retry to public methods (AFTER @CircuitBreaker if present)
    - action: add_annotation_to_methods
      selector:
        visibility: public
        has_body: true
        # Only add to methods that also have @CircuitBreaker (if circuit-breaker module is used)
        # If no @CircuitBreaker, add to all public methods
        prefer_methods_with: "@CircuitBreaker"
      annotation:
        template: "@Retry(name = SERVICE_NAME)"
      position: after_existing_annotations  # IMPORTANT: After @CircuitBreaker
      
  # ─────────────────────────────────────────────────────────────────────────────
  # YAML CONFIGURATION TO MERGE
  # ─────────────────────────────────────────────────────────────────────────────
  yaml_merge:
    file: "src/main/resources/application.yml"
    template: "../templates/config/application-retry.yml.tpl"
    merge_strategy: deep_merge
    path: "resilience4j.retry"
    variables:
      serviceName: "{{serviceName}}"
      maxAttempts: 3
      waitDuration: "500ms"
      enableExponentialBackoff: true
      exponentialBackoffMultiplier: 2
      retryExceptions:
        - "java.io.IOException"
        - "java.util.concurrent.TimeoutException"
        
  # ─────────────────────────────────────────────────────────────────────────────
  # POM DEPENDENCIES
  # ─────────────────────────────────────────────────────────────────────────────
  # Note: resilience4j-spring-boot3 already added by mod-001 (circuit-breaker)
  # If mod-001 is not used, these will be added
  pom_dependencies:
    - groupId: io.github.resilience4j
      artifactId: resilience4j-spring-boot3
      version: "${resilience4j.version}"
      condition: not_exists  # Only add if not already present
    - groupId: org.springframework.boot
      artifactId: spring-boot-starter-aop
      condition: not_exists
      
  pom_properties:
    - name: resilience4j.version
      value: "2.2.0"
      condition: not_exists
      
  # ─────────────────────────────────────────────────────────────────────────────
  # VALIDATION FINGERPRINTS
  # ─────────────────────────────────────────────────────────────────────────────
  fingerprints:
    - pattern: "@Retry"
      file: "*Adapter.java"
      description: "Retry annotation present"
    - pattern: "@Retry.*name = SERVICE_NAME"
      file: "*Adapter.java"
      description: "Retry uses consistent service name"
      
  # ─────────────────────────────────────────────────────────────────────────────
  # ANNOTATION ORDER VALIDATION
  # ─────────────────────────────────────────────────────────────────────────────
  # If both @CircuitBreaker and @Retry are present, @CircuitBreaker MUST come first
  order_validation:
    rule: "@CircuitBreaker before @Retry"
    description: "Circuit breaker must wrap retry, not vice versa"
    error_if_violated: true
