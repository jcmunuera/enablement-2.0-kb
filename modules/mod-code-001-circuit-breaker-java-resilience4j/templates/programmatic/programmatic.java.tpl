// Template: programmatic.java.tpl
// Output: {{basePackage}}/service/{{serviceName}}.java
// Purpose: Programmatic circuit breaker (dynamic config, testing, conditional application)

package {{basePackage}}.service;

import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Service with programmatic circuit breaker.
 * Use when annotation-based approach is not suitable.
 * 
 * Generated by: mod-001-circuit-breaker-java-resilience4j
 * ERI Reference: eri-code-008-circuit-breaker-java-resilience4j
 */
@Service
public class {{serviceName}} {
    
    private static final Logger log = LoggerFactory.getLogger({{serviceName}}.class);
    private final CircuitBreaker circuitBreaker;
    private final {{clientType}} client;
    
    public {{serviceName}}(CircuitBreakerRegistry registry, {{clientType}} client) {
        this.circuitBreaker = registry.circuitBreaker("{{circuitBreakerName}}");
        this.client = client;
    }
    
    public {{returnType}} {{methodName}}({{methodParameters}}) {
        return circuitBreaker.executeSupplier(() -> {
            {{originalMethodBody}}
        });
    }
    
    // With fallback
    public {{returnType}} {{methodName}}WithFallback({{methodParameters}}) {
        try {
            return circuitBreaker.executeSupplier(() -> {
                {{originalMethodBody}}
            });
        } catch (Exception e) {
            log.warn("Circuit breaker fallback triggered: {}", e.getMessage());
            {{fallbackLogic}}
        }
    }
}
