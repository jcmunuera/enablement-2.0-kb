// Template: resttemplate.java.tpl
// Output: {{basePackage}}/adapter/integration/client/{{ApiName}}Client.java
// Purpose: RestTemplate client for REST API integration
// Variant: resttemplate

package {{basePackage}}.adapter.integration.client;

import {{basePackage}}.adapter.integration.dto.{{Entity}}Dto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.List;

/**
 * REST client for {{ApiName}} using RestTemplate.
 * Imperative style with explicit request building.
 * 
 * Recommended for:
 * - Legacy Spring Boot versions (< 3.2)
 * - Existing codebases using RestTemplate
 * 
 * Generated by: mod-018-api-integration-rest-java-spring (resttemplate variant)
 * ERI Reference: eri-code-013-api-integration-rest-java-spring
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class {{ApiName}}Client {
    
    private final RestTemplate restTemplate;
    
    @Value("${integration.{{apiName}}.base-url}")
    private String baseUrl;
    
    public {{Entity}}Dto getById(String id) {
        log.debug("{{ApiName}}: GET {{resourcePath}}/{}", id);
        
        HttpEntity<Void> entity = new HttpEntity<>(createHeaders());
        ResponseEntity<{{Entity}}Dto> response = restTemplate.exchange(
            baseUrl + "{{resourcePath}}/{id}",
            HttpMethod.GET,
            entity,
            {{Entity}}Dto.class,
            id
        );
        return response.getBody();
    }
    
    public List<{{Entity}}Dto> getAll() {
        log.debug("{{ApiName}}: GET {{resourcePath}}");
        
        HttpEntity<Void> entity = new HttpEntity<>(createHeaders());
        ResponseEntity<List<{{Entity}}Dto>> response = restTemplate.exchange(
            baseUrl + "{{resourcePath}}",
            HttpMethod.GET,
            entity,
            new ParameterizedTypeReference<>() {}
        );
        return response.getBody();
    }
    
    public {{Entity}}Dto create({{Entity}}Dto dto) {
        log.debug("{{ApiName}}: POST {{resourcePath}}");
        
        HttpEntity<{{Entity}}Dto> entity = new HttpEntity<>(dto, createHeaders());
        ResponseEntity<{{Entity}}Dto> response = restTemplate.exchange(
            baseUrl + "{{resourcePath}}",
            HttpMethod.POST,
            entity,
            {{Entity}}Dto.class
        );
        return response.getBody();
    }
    
    public {{Entity}}Dto update(String id, {{Entity}}Dto dto) {
        log.debug("{{ApiName}}: PUT {{resourcePath}}/{}", id);
        
        HttpEntity<{{Entity}}Dto> entity = new HttpEntity<>(dto, createHeaders());
        ResponseEntity<{{Entity}}Dto> response = restTemplate.exchange(
            baseUrl + "{{resourcePath}}/{id}",
            HttpMethod.PUT,
            entity,
            {{Entity}}Dto.class,
            id
        );
        return response.getBody();
    }
    
    public void delete(String id) {
        log.debug("{{ApiName}}: DELETE {{resourcePath}}/{}", id);
        
        HttpEntity<Void> entity = new HttpEntity<>(createHeaders());
        restTemplate.exchange(
            baseUrl + "{{resourcePath}}/{id}",
            HttpMethod.DELETE,
            entity,
            Void.class,
            id
        );
    }
    
    /**
     * Creates HTTP headers with correlation ID for traceability.
     */
    private HttpHeaders createHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        String correlationId = MDC.get("correlationId");
        if (correlationId != null) {
            headers.set("X-Correlation-ID", correlationId);
        }
        headers.set("X-Source-System", "{{serviceName}}");
        
        return headers;
    }
}
