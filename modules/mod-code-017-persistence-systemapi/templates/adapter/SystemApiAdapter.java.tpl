// ═══════════════════════════════════════════════════════════════════════════════
// Template: SystemApiAdapter.java.tpl
// Module: mod-code-017-persistence-systemapi
// ═══════════════════════════════════════════════════════════════════════════════
// Output: {{basePackage}}/adapter/out/systemapi/{{Entity}}SystemApiAdapter.java
// Purpose: Adapter implementing repository port via System API calls
// ═══════════════════════════════════════════════════════════════════════════════
// REQUIRED VARIABLES: {{Entity}} {{basePackage}} {{entity}} {{serviceName}} 
// ═══════════════════════════════════════════════════════════════════════════════

package {{basePackage}}.adapter.out.systemapi;

import {{basePackage}}.adapter.out.systemapi.client.{{Entity}}SystemApiClient;
import {{basePackage}}.adapter.out.systemapi.dto.{{Entity}}Dto;
import {{basePackage}}.adapter.out.systemapi.mapper.{{Entity}}SystemApiMapper;
import {{basePackage}}.domain.model.{{Entity}};
import {{basePackage}}.domain.repository.{{Entity}}Repository;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

/**
 * System API adapter implementing {{Entity}}Repository port.
 * Delegates persistence to external System API (mainframe).
 * 
 * IMPORTANT: Resilience patterns are MANDATORY for System API calls.
 * - @CircuitBreaker: Prevents cascade failures
 * - @Retry: Handles transient failures
 * 
 * Annotation order: @CircuitBreaker (outer) -> @Retry (inner)
 * 
 * Generated by: mod-017-persistence-systemapi
 * ERI Reference: eri-code-012-persistence-patterns-java-spring
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class {{Entity}}SystemApiAdapter implements {{Entity}}Repository {
    
    private static final String SERVICE_NAME = "{{serviceName}}";
    
    private final {{Entity}}SystemApiClient client;
    private final {{Entity}}SystemApiMapper mapper;
    
    @Override
    @CircuitBreaker(name = SERVICE_NAME, fallbackMethod = "findByIdFallback")
    @Retry(name = SERVICE_NAME)
    public Optional<{{Entity}}> findById(String id) {
        log.debug("Fetching {{entity}} with id: {}", id);
        {{Entity}}Dto dto = client.getById(id);
        return Optional.ofNullable(mapper.toDomain(dto));
    }
    
    @Override
    @CircuitBreaker(name = SERVICE_NAME, fallbackMethod = "findAllFallback")
    @Retry(name = SERVICE_NAME)
    public List<{{Entity}}> findAll() {
        log.debug("Fetching all {{entity}}s");
        List<{{Entity}}Dto> dtos = client.getAll();
        return dtos.stream()
            .map(mapper::toDomain)
            .toList();
    }
    
    @Override
    @CircuitBreaker(name = SERVICE_NAME, fallbackMethod = "saveFallback")
    @Retry(name = SERVICE_NAME)
    public {{Entity}} save({{Entity}} entity) {
        log.debug("Saving {{entity}}: {}", entity.getId());
        {{Entity}}Dto dto = mapper.toDto(entity);
        {{Entity}}Dto saved = client.save(dto);
        return mapper.toDomain(saved);
    }
    
    @Override
    @CircuitBreaker(name = SERVICE_NAME, fallbackMethod = "deleteByIdFallback")
    @Retry(name = SERVICE_NAME)
    public void deleteById(String id) {
        log.debug("Deleting {{entity}} with id: {}", id);
        client.deleteById(id);
    }
    
    // ========== Fallback Methods ==========
    
    private Optional<{{Entity}}> findByIdFallback(String id, Throwable t) {
        log.error("Circuit breaker fallback for findById({}): {}", id, t.getMessage());
        throw new SystemApiUnavailableException("{{Entity}} service unavailable", t);
    }
    
    private List<{{Entity}}> findAllFallback(Throwable t) {
        log.error("Circuit breaker fallback for findAll(): {}", t.getMessage());
        throw new SystemApiUnavailableException("{{Entity}} service unavailable", t);
    }
    
    private {{Entity}} saveFallback({{Entity}} entity, Throwable t) {
        log.error("Circuit breaker fallback for save({}): {}", entity.getId(), t.getMessage());
        throw new SystemApiUnavailableException("{{Entity}} service unavailable", t);
    }
    
    private void deleteByIdFallback(String id, Throwable t) {
        log.error("Circuit breaker fallback for deleteById({}): {}", id, t.getMessage());
        throw new SystemApiUnavailableException("{{Entity}} service unavailable", t);
    }
}
